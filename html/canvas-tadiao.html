<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>塔吊</title>
    <link rel="stylesheet" href="https://cdn.staticfile.org/layui/2.5.6/css/layui.min.css">
    <script src="https://cdn.staticfile.org/jquery/3.5.1/jquery.js"></script>
    <script src="https://cdn.staticfile.org/layui/2.5.6/layui.min.js"></script>
    <style>
        canvas{
            border: 1px solid #ccc;
            margin-left: calc(50% - 252px);
        }
    </style>
</head>

<body>
    <div class="row">
        <div class="layui-col-md6">
            <canvas id="circle-canvas" width="500" height="500"></canvas>
        </div>
        <div class="layui-col-md6">
            <canvas id="myArc" width="500" height="500">你的版本不支持canvas</canvas>
            <br>
            <br>
            当前-> x：<input type="text" id="curX">y：<input type="text" id="curY">
            <br>
            <br>
            目标-> x：<input type="text" id="toX">y：<input type="text" id="toY">
            <br>
            <br>
            <button onclick="changeLeft()">左移</button>
            <button onclick="changeRight()">右移</button>
            <button onclick="changeUp()">上移</button>
            <button onclick="changeDown()">下移</button>
            <button onclick="moveTo()">向目标移动</button>
            <button onclick="changeCancel()">取消移动</button>
        </div>
    </div>
</body>
<script>
    var mCanvas; //声明Canvas对象;
    var cxt; //声明context对象,该对象拥有丰富的绘图的API

    var offCanvas; //声明多级防碰撞Canvas对象;
    var offCxt; //声明多级防碰撞context对象,该对象拥有丰富的绘图的API

    // 塔吊幅度和高度
    var cHeight = 240;
    var cX = 180;
    var cY;

    var changeLeftFn;
    var changeRightFn;
    var changeUpFn;
    var changeDownFn;

    // var styleColor = "rgb(0,123,236)";  // 塔吊颜色统一设置
    var styleColor = "rgb(76,76,76)";

    // 多级防碰撞回转角度
    var r = 80;

    // 多级防碰撞圆形放大倍数
    var circleScale = 1;

    function initMikyouCanvas(mCanvas, cxt) {
        this.mCanvas = mCanvas;
        this.cxt = cxt;
    }

    /**
     * 1、绘制矩形(主要分为:绘制填充矩形和绘制边框矩形和清除矩形区域(利用isClear标记是否绘制清除矩形，实际上就是绘制一个与画布背景色一致的矩形区域),利用isFill变量来标记)
     * 主要使用canvas原生的API:FillRect(x,y,width,height),StrokeRect(x,y,width,height),ClearRect(x,y,width,height)
     * 自己封装的参数:drawRect(x,y,width,height,isClear,isFill,bgColor)
     * x:矩形起点的X坐标(注意：相对坐标系是以画布的左上角为原点，向右为X坐标正方向，向下为Y坐标的正方向)
     * y:矩形终点的Y坐标
     * width:矩形的宽度
     * height:矩形的高度
     * isClear:是否绘制清除画布的矩形区域，true则就是绘制一个清除画布矩形区域，false就是绘制其他两种矩形
     * isFill:是否是填充，false为绘制边框，true为绘制填充
     * bgColor:矩形的颜色，若为填充则为整个矩形背景色，边框则为边框色
     */
    function drawRect(x, y, width, height, isClear, isFill, bgColor) {
        if (isClear) { //为true表示绘制清除画布的矩形区域,那么传入的isFill, bgColor值可以为任意值
            cxt.clearRect(x, y, width, height);
        } else { //false
            if (isFill) { //为true，则绘制填充矩形
                cxt.fillStyle = bgColor;
                cxt.fillRect(x, y, width, height);
            } else { //为false,则绘制边框矩形
                cxt.strokeStyle = bgColor;
                cxt.strokeRect(x, y, width, height);
            }
        }
    }

    /**
     * 2、绘制圆弧(主要分为：绘制填充圆弧和绘制圆弧边框利用isFill变量来标记,注意：在绘制圆弧边框的时候还有一种特殊情况就是，只需要仅仅绘制弧边，不需要绘制圆弧开始起点和终点之间的连线，这个就是调用了beginPath()不需要调用closePath(),这里也使用一个isOnlyArc变量来标记true为仅仅绘制弧边
     *其他的正常)
     * 主要是使用的是canvas原生的API:
     * arc(x,y,radius,startAngle,endAngle,anticlockwise);
     * x:圆心X坐标
     * y:圆心Y坐标
     * startAngle:开始的弧度
     * endAngle:结束的弧度
     * anticlockwise:true为逆时针，false为顺时针
     * 自己封装的参数:drawCircle(x,y,radius,startAngle，endAngle,anticlockwise,isFill，bgColor)
     * x:圆心X坐标
     * y:圆心Y坐标
     * startAngle:开始的角度(通过getAngle方法将传入的角度转换成相应角度的弧度，
     *     因为在原生的绘制圆弧的API它是根据弧度大小来绘制的，例如如果你想绘制一个30度的圆弧，如果直接传入30是不行的，要传入Math.PI/6
     * 所以在这里个人做了一个优化，直接传入30就通过getAngle方法转换成Math.PI/6，这样就很方便的绘制自己传入的角度大小的圆弧。
     * )
     * endAngle:结束的角度
     * 注意:如果要绘制圆形那么只需要调用该方法，传入的startAngle和endAngle是0度和360度即可。
     * anticlockwise:true为逆时针，false为顺时针
     * isFill:是否是填充，false为绘制边框，true为绘制填充
     * bgColor:圆弧的颜色
     */
    function drawArc(x, y, radius, startAngle, endAngle, anticlockwise, isOnlyArc, isFill, bgColor) {
        if (isFill) { //为true绘制填充圆弧
            cxt.fillStyle = bgColor;
            cxt.beginPath();
            cxt.arc(x, y, radius, getAngle(startAngle), getAngle(endAngle), anticlockwise);
            cxt.closePath();
            cxt.fill();
        } else { //为false绘制边框圆弧
            cxt.strokeStyle = bgColor;
            cxt.beginPath();
            cxt.arc(x, y, radius, getAngle(startAngle), getAngle(endAngle), anticlockwise);
            if (isOnlyArc) { //绘制边框的另一种情况就是仅仅绘制弧边不需要调用closePath()

            } else { //否则就是不仅绘制边框还得绘制起点和终点的连线，需要调用了closePath();
                cxt.closePath();
            }
            cxt.stroke();
        }
    }

    /**
     * 3、绘制扇形(主要分为：绘制填充扇形和绘制扇形边框利用isFill变量来标记）
     *主要是使用的是canvas原生的API:
     * arc(x,y,radius,startAngle,endAngle,anticlockwise);
     * x:圆心X坐标
     * y:圆心Y坐标
     * startAngle:开始的弧度
     * endAngle:结束的弧度
     * anticlockwise:true为逆时针，false为顺时针
     * 自己封装参数API:drawSector(x,y,radius,startAngle,endAngle,anticlockwise,isFill,bgColor);
     * x:圆心X坐标
     * y:圆心Y坐标
     * startAngle:开始的角度(通过getAngle方法将传入的角度转换成相应角度的弧度，
     *     因为在原生的绘制圆弧的API它是根据弧度大小来绘制的，例如如果你想绘制一个30度的圆弧，如果直接传入30是不行的，要传入Math.PI/6
     * 所以在这里个人做了一个优化，直接传入30就通过getAngle方法转换成Math.PI/6，这样就很方便的绘制自己传入的角度大小的圆弧。
     * )
     * endAngle:结束的角度
     * anticlockwise:true为逆时针，false为顺时针
     * isFill:是否是填充，false为绘制边框，true为绘制填充
     * bgColor:扇形的颜色
     */
    function drawSector(x, y, radius, startAngle, endAngle, anticlockwise, isFill, bgColor) {
        if (isFill) {
            cxt.fillStyle = bgColor;

            cxt.beginPath();
            cxt.moveTo(x, y); //把路径移动到画布中的指定点，不创建线条，注意：绘制扇形唯一与绘制弧的区别在于，紧跟着beginPath()后面调用，首先将路径移动到圆心位置
            cxt.arc(x, y, radius, getAngle(startAngle), getAngle(endAngle), false);
            cxt.closePath();
            cxt.fill();
        } else {
            cxt.strokeStyle = bgColor;

            cxt.beginPath();
            cxt.moveTo(x, y);
            cxt.arc(x, y, radius, getAngle(startAngle), getAngle(endAngle), false);
            cxt.closePath();
            cxt.stroke();
        }
    }

    /**
     * @description 4、绘制线段(主要分为：绘制填充线段和绘制空心线段利用isFill变量来标记）
     * 主要是使用的是canvas原生的API:
     * lineTo(x,y):表示从某点连线到该坐标点
     *moveTo(x,y):表示将路径移动到画布中的该坐标点
     * x:画布中某点的X坐标
     * y:画布中某点的Y坐标
     * 注意：如果开始没有调用moveTo,那么第一个lineTo的功能就相当于一个moveTo
     * 自己封装的API:drawLine(startX,startY,endX,endY,lineWidth,bgcolor)
     * 
     * startX:表示线的起点的X坐标
     * startY:表示起点的Y坐标
     * endX:表示线的终点的X坐标
     * endY:表示线的终点的Y坐标
     * lineWidth:表示线段的宽度
     * bgColor:线的颜色
     */
    function drawLine(startX, startY, endX, endY, lineWidth, bgColor) {
        cxt.beginPath();
        cxt.lineWidth = lineWidth;
        cxt.strokeStyle = bgColor;
        cxt.moveTo(startX, startY);
        cxt.lineTo(endX, endY);
        cxt.stroke();
        cxt.fill();
    }

    /**
     * 圆形图中长臂和短臂线段
     */
    function circleDrawLine(startX, startY, endX, endY, lineWidth, bgColor) {
        offCxt.beginPath();
        offCxt.lineWidth = lineWidth;
        offCxt.strokeStyle = bgColor;
        offCxt.moveTo(startX, startY);
        offCxt.lineTo(endX, endY);
        offCxt.stroke();
        offCxt.fill();
    }

    /**
     * @description 5、绘制贝塞尔曲线
     * drawBezierCurve
     */

    //将角度转换成弧度函数，
    function getAngle(arc) {
        return Math.PI * (arc / 180);
    }

    /**
     * @description 6、吊钩
     * variousHooks
     * x原点横坐标,
     * y原点纵坐标,
     * X变量值左右,
     * Y变量值上下,
     * bgColor颜色
     */
    function variousHooks(x, y, X, Y, bgColor,lineWidth) {
        cxt.beginPath();
        if(lineWidth == 2){
            cxt.lineWidth = 18;
        }else{
            cxt.lineWidth = 1;
        }
        cxt.strokeStyle = bgColor;
        cxt.fillStyle = bgColor;
        //钩子头部分
        // cxt.moveTo(x + 5 + X, y);
        // cxt.lineTo(x + 35 + X, y);
        cxt.moveTo(x + 5 + X, y + 10);
        cxt.lineTo(x + 35 + X, y + 10);
        cxt.moveTo(x + 10 + X, y+1);
        cxt.lineTo(x + 10 + X, y + 10);
        cxt.moveTo(x + 30 + X, y+1);
        cxt.lineTo(x + 30 + X, y + 10);
        cxt.moveTo(x + 11 + X, y + 10);
        cxt.lineTo(x + 11 + X, y + 10 + Y);
        cxt.moveTo(x + 29 + X, y + 10);
        cxt.lineTo(x + 29 + X, y + 10 + Y);
        //半圆
        cxt.moveTo(x + 20 + X, y + 10 + Y);
        cxt.arc(x + 20 + X, y + 10 + Y, 10, 0, 180 * Math.PI / 180, false);
        cxt.moveTo(x + 20 + X, y + 10 + Y + 5);
        cxt.lineTo(x + 10 + X, y + 10 + Y + 15);
        cxt.moveTo(x + 20 + X, y + 10 + Y + 5);
        cxt.lineTo(x + 30 + X, y + 10 + Y + 15);
        cxt.moveTo(x + 30 + X, y + 10 + Y + 15);
        cxt.lineTo(x + 30 + X, y + 10 + Y + 35);
        cxt.lineTo(x + 10 + X, y + 10 + Y + 35);
        cxt.lineTo(x + 10 + X, y + 10 + Y + 35);
        cxt.lineTo(x + 10 + X, y + 10 + Y + 15);
        cxt.lineTo(x + 30 + X, y + 10 + Y + 15);
        cxt.stroke();
        cxt.fill();
    }

    /**
     * 塔吊臂长转动区域
     * 圆心坐标: (x, y)
     * 半径: radius
     * 起始角度: startAngle
     * 结束角度: endAngle
     * 是否逆时针旋转: false 代表顺时针旋转
     */
    function circleRender(x, y, radius, startAngle, endAngle, color,fillStyle, Boolean) {
        offCxt.beginPath();
        offCxt.lineWidth = 1;
        offCxt.strokeStyle = color;
        offCxt.arc(x,y,radius,startAngle*Math.PI/180,endAngle*Math.PI/180);
        offCxt.stroke();
        if (fillStyle){
            offCxt.fillStyle = fillStyle;
            offCxt.fill();
        }
        offCxt.closePath();
    }

    /**
     * 塔吊转动区域黄色区域
     */
    function circleYellowRender(x, y, radius, startAngle, endAngle, color, Boolean) {
        // x += 250;
        // y = 500 - y;
        offCxt.beginPath();
        offCxt.strokeStyle = color;
        offCxt.arc(x,y,radius,startAngle*Math.PI/180,endAngle*Math.PI/180);
        // offCxt.lineTo(x,y);
        offCxt.fillStyle = color;
        offCxt.stroke();
        offCxt.fill();
        offCxt.closePath();
    }

    /**
     * 塔吊转动区域长臂短臂
     */
    function circleLineRender(x, y, radius, startAngle, endAngle, color, Boolean) {
        // x += 250;
        // y = 500 - y;
        offCxt.beginPath();
        offCxt.strokeStyle = color;
        offCxt.arc(x,y,radius,startAngle*Math.PI/180,endAngle*Math.PI/180);
        offCxt.lineTo(x,y);
        offCxt.fillStyle = color;
        offCxt.stroke();
        offCxt.fill();
        offCxt.closePath();
    }

    /**
     * 圆上点坐标计算
     */
    function circlePoint(x, y, radius, angle) {
        var x1 = x + radius * Math.cos( getAngle(angle) );
        var y1 = y + radius * Math.sin( getAngle(angle) );
        return {x:x1,y:y1}
    }

    /**
     * 两点之间距离计算
     */
    function GetDistance( lat1,  lng1,  lat2,  lng2){
        var xdiff = lat2 - lat1; // 计算两个点的横坐标之差
        var ydiff = lng2 - lng1; // 计算两个点的纵坐标之差
        return Math.pow((xdiff * xdiff + ydiff * ydiff), 0.5);
    }

    /**
     * 塔机转动区域长臂短臂
     */
    function circleLine(x, y, longRadius, shortRadius, angle) {
        // x+=250;
        // y = 500 - y;
        var point1 = circlePoint(x, y, longRadius, angle);
        var point2 = circlePoint(x, y, shortRadius, angle+180);
        circleDrawLine(x, y, point1.x, point1.y, 1, "#999");
        circleDrawLine(x, y, point2.x, point2.y, 1, "#999");
    }

    /**
     * 绘制塔吊载重幅度区域
     */
    function loadRange() {
        var range = [2.5,39.2,40,42.5,45,47.5,50,52.5,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        var load = [3000,3000,2950,2740,2550,2380,2220,2090,1960,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        var rangeMax = Math.max.apply(null,range);
        var rangeScale = 180/rangeMax;
        var loadMax = Math.max.apply(null,load);
        var loadScale = 180/loadMax;
        range = range.map(function (i) {
            return i * rangeScale;
        });
        load = load.map(function (i) {
            return i * loadScale;
        });
        var arr = [[0,0],[0,loadMax*loadScale]];
        range.forEach(function (i,index) {
            if (i==0&&load[index]==0){
                return false;
            }
            arr.push([i,load[index]]);
        });
        arr.push([rangeMax*rangeScale,0],[0,0]);
        // cxt.bezierCurveTo(x1, y1, x2, y2, x, y) // 贝塞尔曲线
        cxt.beginPath();
        cxt.lineWidth = 1;
        cxt.strokeStyle = "red";
        cxt.moveTo(arr[0], arr[1]);
        arr.forEach(function (j) {
            cxt.lineTo(200+j[0], -j[1]+400);
        });
        cxt.stroke();
    }

    /**
     * @description 7、叉线
     * wiredCables
     */
    function wiredCables(x, y, lineWidth, bgColor) {
        cxt.beginPath();
        cxt.lineWidth = lineWidth;
        cxt.strokeStyle = bgColor;
        cxt.moveTo(x - 10, y + 15);
        cxt.lineTo(x + 10, y - 15);
        cxt.moveTo(x - 10, y - 15);
        cxt.lineTo(x + 10, y + 15);
        cxt.stroke();
        cxt.fill();
    }

    /**
     * @description 8、文字
     * wiredCables
     */
    function drawText(text, x, y, color, font, textAlign) {
        cxt.font = font;
        cxt.textAlign = textAlign;
        cxt.fillStyle = color;
        cxt.fillText(text, x, y);
    }

    function drawOffCxtText(text, x, y, color, font, textAlign) {
        offCxt.font = font;
        offCxt.textAlign = textAlign;
        offCxt.fillStyle = color;
        offCxt.fillText(text, x, y);
    }

    function initCanvas() { //onload事件加载该方法，当HTML5页面加载的时候就会回调该方法
        mCanvas = document.getElementById("myArc"); //初始化canvas对象,这里只是获得了Canvas的这个整个的标签---<canvas id="mCanvas" width="500" height="500"></canvas>
        cxt = mCanvas.getContext("2d"); //初始化cxt对象,然后就去获得canvas的上下文对象cxt,注意传入参数为2d表示绘制2d平面，cxt得到的是一个canvasRenderingContext2D对象，里面封装了大量的canvas绘图API
        cxt.clearRect(0, 0, mCanvas.width, mCanvas.height);

        //初始化Canvas
        initMikyouCanvas(mCanvas, cxt);
        /**canvas各种绘图的API**/
        //1、绘制矩形，drawRect(x,y,width,height,isClear,isFill,bgColor);
        drawRect(150, 370, 20, 30, false, false, styleColor);
        drawRect(150, 340, 20, 30, false, false, styleColor);
        drawRect(150, 310, 20, 30, false, false, styleColor);
        drawRect(150, 280, 20, 30, false, false, styleColor);
        drawRect(150, 250, 20, 30, false, false, styleColor);
        drawRect(150, 220, 20, 30, false, false, styleColor);
        drawRect(150, 190, 20, 30, false, false, styleColor);
        drawRect(150, 160, 20, 30, false, false, styleColor);
        drawRect(150, 115, 10, 40, false, true, styleColor);
        //左小重物
        drawRect(57, 113, 9, 15, false, true, styleColor);
        drawRect(67, 113, 9, 15, false, true, styleColor);
        drawRect(77, 113, 9, 15, false, true, styleColor);
        //3、绘制圆形
        //支柱交点
        drawArc(150, 400, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 370, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 340, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 310, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 280, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 250, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 220, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 190, 2, 0, 360, false, false, true, styleColor);
        drawArc(150, 160, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 400, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 370, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 340, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 310, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 280, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 250, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 220, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 190, 2, 0, 360, false, false, true, styleColor);
        drawArc(170, 160, 2, 0, 360, false, false, true, styleColor);
        //5、绘制线段 drawLine(startX, startY, endX, endY, lineWidth,bgColor)
        drawLine(110, 400, 210, 400, 1, styleColor);
        drawLine(135, 400, 150, 340, 1, styleColor);
        drawLine(185, 400, 170, 340, 1, styleColor);
        //驾驶室
        drawLine(160, 115, 170, 115, 1, styleColor);
        drawLine(170, 115, 180, 135, 1, styleColor);
        drawLine(180, 135, 160, 135, 1, styleColor);
        drawLine(180, 135, 170, 155, 1, styleColor);
        drawLine(170, 155, 160, 155, 1, styleColor);
        //塔吊尖
        drawLine(150, 110, 170, 110, 1, styleColor);
        drawLine(150, 110, 160, 20, 1, styleColor);
        drawLine(170, 110, 160, 20, 1, styleColor);
        drawLine(152, 90, 168, 90, 1, styleColor);
        drawLine(155, 70, 165, 70, 1, styleColor);
        drawLine(158, 50, 162, 50, 1, styleColor);

        drawLine(160, 45, 85, 80, 1, styleColor);
        drawLine(160, 45, 88, 80, 1, styleColor);
        drawLine(160, 45, 91, 80, 1, styleColor);

        drawLine(160, 45, 240, 90, 1, styleColor);
        drawLine(160, 45, 243, 90, 1, styleColor);
        drawLine(160, 45, 246, 90, 1, styleColor);
        drawLine(160, 45, 350, 90, 1, styleColor);
        drawLine(160, 45, 353, 90, 1, styleColor);
        drawLine(160, 45, 356, 90, 1, styleColor);
        //右臂上下线条
        drawLine(170, 110, 390, 110, 1, styleColor);
        drawLine(180, 90, 380, 90, 1, styleColor);

        //上下线见得线    比例1:2
        drawLine(170, 110, 180, 90, 1, styleColor);
        drawLine(190, 110, 180, 90, 1, styleColor);
        drawLine(190, 110, 200, 90, 1, styleColor);
        drawLine(210, 110, 200, 90, 1, styleColor);
        drawLine(210, 110, 220, 90, 1, styleColor);
        drawLine(230, 110, 220, 90, 1, styleColor);
        drawLine(230, 110, 240, 90, 1, styleColor);
        drawLine(250, 110, 240, 90, 1, styleColor);
        drawLine(250, 110, 260, 90, 1, styleColor);
        drawLine(270, 110, 260, 90, 1, styleColor);
        drawLine(270, 110, 280, 90, 1, styleColor);
        drawLine(290, 110, 280, 90, 1, styleColor);
        drawLine(290, 110, 300, 90, 1, styleColor);
        drawLine(310, 110, 300, 90, 1, styleColor);
        drawLine(310, 110, 320, 90, 1, styleColor);
        drawLine(330, 110, 320, 90, 1, styleColor);
        drawLine(330, 110, 340, 90, 1, styleColor);
        drawLine(350, 110, 340, 90, 1, styleColor);
        drawLine(350, 110, 360, 90, 1, styleColor);
        drawLine(370, 110, 360, 90, 1, styleColor);
        drawLine(370, 110, 380, 90, 1, styleColor);
        drawLine(390, 110, 380, 90, 1, styleColor);

        //左吊臂
        drawLine(55, 110, 150, 110, 1, styleColor);
        drawLine(55, 110, 55, 80, 1, styleColor);
        drawLine(85, 110, 85, 80, 1, styleColor);
        drawLine(115, 110, 115, 80, 1, styleColor);
        drawLine(145, 110, 145, 80, 1, styleColor);
        drawLine(55, 100, 145, 100, 1, styleColor);
        drawLine(55, 90, 145, 90, 1, styleColor);
        drawLine(55, 80, 145, 80, 1, styleColor);

        //左小重物竖线
        drawLine(62, 110, 62, 130, 1, styleColor);
        drawLine(72, 110, 72, 130, 1, styleColor);
        drawLine(82, 110, 82, 130, 1, styleColor);

        //6.控制吊钩的运动  以(165,110)为原点  X~(0--180),Y~(0--240)
        variousHooks(165, 110, cX, cHeight, styleColor);
        $("#curX").val(cX);
        $("#curY").val(cHeight);
        // variousHooks(165, 110, 180, 240, "#fff");

        //7.绘制叉线    y递减30
        wiredCables(160, 385, 1, styleColor);
        wiredCables(160, 355, 1, styleColor);
        wiredCables(160, 325, 1, styleColor);
        wiredCables(160, 295, 1, styleColor);
        wiredCables(160, 265, 1, styleColor);
        wiredCables(160, 235, 1, styleColor);
        wiredCables(160, 205, 1, styleColor);
        wiredCables(160, 175, 1, styleColor);
        //8 吊钩区域文字
        drawText('尾臂长', 60, 35, "#666", '15px 微软雅黑', "left");
        drawText('xxx米', 65, 55, "#666", '15px 微软雅黑', "left");
        drawText('塔身高', 60, 150, "#666", '15px 微软雅黑', "left");
        drawText('xxx米', 65, 170, "#666", '15px 微软雅黑', "left");
        drawText('更新时间: ', 75, 430, "#666", '15px 微软雅黑', "left");
        drawText(formatDate(new Date(),"yyyy-MM-dd hh:mm:ss"), 160, 430, "#666", '15px 微软雅黑', "left");
        drawText('臂长', 350, 35, "#666", '15px 微软雅黑', "left");
        drawText('xxx米', 340, 55, "#666", '15px 微软雅黑', "left");

        //9 绘制塔吊载重幅度区域
        loadRange();
    }

    function initoffCanvas(arr){
        offCanvas = document.getElementById("circle-canvas"); //初始化canvas对象,这里只是获得了Canvas的这个整个的标签---<canvas id="circle-canvas" width="500" height="500"></canvas>
        offCxt = offCanvas.getContext("2d"); //初始化cxt对象,然后就去获得canvas的上下文对象cxt,注意传入参数为2d表示绘制2d平面，cxt得到的是一个canvasRenderingContext2D对象，里面封装了大量的canvas绘图API
        offCxt.clearRect(0, 0, offCanvas.width, offCanvas.height);

        // 先将原点移动到左下
        // offCxt.translate(0, offCanvas.height);
        // 然后，利用坐标缩放，缩放y轴倍数为-1，这样子y轴就会“缩回去”，从而达到反转y轴的效果，如下：
        // offCxt.scale(1, -1);

        // 多级防碰撞
        // circleYellowRender(x, y, radius, startAngle, endAngle,color, Boolean)
        // circleYellowRender(175,114,55,80,180,"#ffff00ab");

        // circleRender(x, y, radius, startAngle, endAngle,color, fillStyle, Boolean)
        // circleRender(175,114,55,0,360,"#999","#c8f9d278");
        // circleRender(175,114,3,0,360,"#999","#ff00009c");
        // circleRender(227,188,55,0,360,"#999");
        // circleRender(227,188,3,0,360,"#999","#ff00009c");
        //
        // circleLine(175,114,55,14,r-90);
        // circleLine(227,188,55,14,322.6-90);

        arr.forEach(function (i) {
            circleRender(i.x,i.y,i.radius,0,360,"#999",i.fillStyle);
            circleRender(i.x,i.y,3,0,360,"#999","#ff00009c");
        });

        arr.forEach(function (i) {
            debugger
            circleLine(i.x,i.y,i.radius,i.shortRadius,i.angle);
        });

    }

    window.onload = function () {

        // 模拟数据
        // x横坐标 y纵坐标 radius长臂（半径） shortRadius短臂 startAngle开始角度 endAngle结束角度 angle回转角度
        var arr = [
            {x:175,y:114,radius:55,shortRadius:14,startAngle:0,endAngle:360,angle: 80},
            {x:227,y:188,radius:55,shortRadius:14,startAngle:0,endAngle:360,angle:322},
            {x:120,y:120,radius:55,shortRadius:14,startAngle:0,endAngle:360,angle:322}
        ];

        // 计算放大倍数
        arr = setCircleScale(arr);

        initCanvas();
        initoffCanvas(arr);

        // 监听多级防碰撞鼠标事件
        var points = arr;//原点圆心集合
        var cP = getLeftRight(offCanvas);//offCanvas
        var timer;
        offCanvas.addEventListener('mousemove', function (e) {
            clearTimeout(timer);
            var x = e.clientX, y = e.clientY;
            timer = setTimeout(function () {
                for (var i = 0; i < points.length; i++){
                    if (hitCheck(x - cP.x, y - cP.y, points[i], points[i].radius)) {
                        initoffCanvas(arr);
                        drawOffCxtText('xxx米',  points[i].x,points[i].y, "#666", '15px 微软雅黑', "left");
                        return;
                    }else {
                        initoffCanvas(arr);
                    }
                }
            }, 100);
        }, false);
    };



    function changeLeft(x) {
        clearTimeout(changeLeftFn);
        clearTimeout(changeRightFn);
        changeLeftFn = setInterval(function () {
            if ((x&&cX==x)||cX==0){
                clearTimeout(changeLeftFn);
                return false;
            }
            // variousHooks(165, 110, cX, cHeight, "#fff",2);
            // cHeight = cHeight - 1;
            cX = cX - 1;
            // variousHooks(165, 110, cX, cHeight, styleColor);
            initCanvas()
        }, 40)
    }
    function changeRight(x) {
        clearTimeout(changeLeftFn);
        clearTimeout(changeRightFn);
        changeRightFn = setInterval(function () {
            if (x&&cX==0){
                clearTimeout(changeRightFn);
                return false;
            }
            // variousHooks(165, 110, cX, cHeight, "#fff",2);
            // cHeight = cHeight - 1;
            cX = cX + 1;
            initCanvas()
            // variousHooks(165, 110, cX, cHeight, styleColor);
        }, 40)
    }
    function changeUp(y) {
        clearTimeout(changeUpFn);
        clearTimeout(changeDownFn);
        changeUpFn = setInterval(function () {
            if ((y&&cHeight==y)||cHeight==0){
                clearTimeout(changeUpFn);
                return false;
            }
            // variousHooks(165, 110, cX, cHeight, "#fff",2);
            cHeight = cHeight - 1;
            // cX = cX - 1;
            // variousHooks(165, 110, cX, cHeight, styleColor);
            initCanvas()
        }, 40)
    }
    function changeDown(y) {
        clearTimeout(changeUpFn);
        clearTimeout(changeDownFn);
        changeDownFn = setInterval(function () {
            if (y&&cHeight==y){
                clearTimeout(changeDownFn);
                return false;
            }
            // variousHooks(165, 110, cX, cHeight, "#fff",2);
            cHeight = cHeight + 1;
            // cX = cX - 1;
            // variousHooks(165, 110, cX, cHeight, styleColor);
            initCanvas()
        }, 40)
    }

    // 移动
    function moveTo(x,y) {

        var curX = parseInt($("#curX").val());
        var curY = parseInt($("#curY").val());

        x = parseInt($("#toX").val());
        y = parseInt($("#toY").val());
        if (x>curX){
            changeRight(x)
        } else {
            changeLeft(x)
        }
        if (y>curY){
            changeDown(y)
        } else {
            changeUp(y)
        }

    }

    function changeCancel() {
        clearTimeout(changeLeftFn);
        clearTimeout(changeRightFn);
        clearTimeout(changeUpFn);
        clearTimeout(changeDownFn);
    }

    // canvas默认宽高
    var defaultCanvasHeight = 500;
    var defaultCanvasWidth = 500;

    /**
     * 计算多级防碰撞圆形放大倍数，初始化数据
     */
    function setCircleScale(arr) {
        arr = arr || [];
        if (arr.length == 1){
            // 计算能放大的最小倍率
            var scale1 = defaultCanvasHeight/(arr[0].radius*2);
            var scale2 = defaultCanvasWidth/(arr[0].radius*2);
            circleScale =  scale1 < scale2 ? scale1 : scale2;
            // 数据按倍率放大初始化数据
            arr = arr.map(function (i) {
                return {
                    x:defaultCanvasWidth/2,
                    y:defaultCanvasHeight/2,
                    radius:defaultCanvasWidth/2,
                    shortRadius:i.shortRadius*circleScale,
                    startAngle:0,
                    endAngle:360,
                    fillStyle: "#c8f9d278",
                    angle:i.angle-90
                };
            })
        }else {
            var xArr = [], yArr = [];
            arr.forEach(function (i) {
                xArr.push({x:i.x,radius:i.radius});
                yArr.push({y:i.y,radius:i.radius});
            });
            xArr = xArr.sort(function (a,b) {
                return a.x - b.x
            });
            yArr = yArr.sort(function (a,b) {
                return a.y - b.y
            });
            // 计算能放大的最小倍率
            var scale = [];
            for (var i = 0; i < xArr.length; i++){
                for (var j= i+1; j < xArr.length; j++){
                    scale.push(defaultCanvasWidth/(xArr[j].x - xArr[i].x + xArr[j].radius + xArr[i].radius));
                    scale.push(defaultCanvasHeight/(yArr[j].y - yArr[i].y + yArr[j].radius + yArr[i].radius));
                }
            }
            scale = scale.sort();
            circleScale = scale[0];
            // 坐标平移量
            var translationX = circleScale * xArr[0].x - xArr[0].radius * circleScale;
            var translationY = circleScale * yArr[0].y - yArr[0].radius * circleScale;
            arr = arr.map(function (i) {
                return {
                    x:i.x*circleScale-translationX,
                    y:defaultCanvasHeight-(i.y*circleScale)+translationY,
                    radius:i.radius*circleScale,
                    shortRadius:i.shortRadius*circleScale,
                    startAngle:0,
                    endAngle:360,
                    fillStyle: "#c8f9d278",
                    angle:i.angle-90
                };
            })
        }
        return arr;
    }

    /**
     * 格式化时间
     * fmt: 'yyyy', 'yyyy-MM-dd', 'yy-MM-dd', 'yyyy-MM-dd hh:mm:ss'
     */
    function formatDate(date, fmt) {
        if (!date){
            return '';
        }
        if (typeof date == 'string') {
            return date;
        }
        date = new Date(date);
        if (!fmt) fmt = "yyyy-MM-dd hh:mm:ss";

        if (!date || date == null) return null;
        var o = {
            'M+': date.getMonth() + 1, // 月份
            'd+': date.getDate(), // 日
            'h+': date.getHours(), // 小时
            'm+': date.getMinutes(), // 分
            's+': date.getSeconds(), // 秒
            'q+': Math.floor((date.getMonth() + 3) / 3), // 季度
            'S': date.getMilliseconds() // 毫秒
        };
        if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
        for (var k in o) {
            if (new RegExp('(' + k + ')').test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length)))
        }
        return fmt
    }

    function getLeftRight(o) {
        var p = { x: o.offsetLeft, y: o.offsetTop };
        while (o = o.offsetParent) { p.x += o.offsetLeft; p.y += o.offsetTop; }
        return p;
    }

    function hitCheck(x, y, point, r) {//检查是否移动到点上，直接按照正方形检查了，圆形比较麻烦
        var x1 = point.x, y1 = point.y;
        var length = GetDistance(x,y,x1,y1);
        console.log(length);
        return length <= r;
    }

    /**
     * websocket实时数据
     */
    // var ws = new WebSocket("ws://localhost:8080/");
    // // 初始化WebSocket对象
    // ws.onopen = function () {
    //     console.log("Conncet open");
    // };
    // ws.onmessage = function (evt) {
    //     var data = evt.data;
    // };
    // ws.onclose = function () {
    //     console.log("Connect close");
    // };


</script>

</html>